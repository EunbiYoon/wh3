[
    {
        "label": "Digraph",
        "importPath": "graphviz",
        "description": "graphviz",
        "isExtraImport": true,
        "detail": "graphviz",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "visualize_tree_from_dict",
        "kind": 2,
        "importPath": "saved_trees.tree",
        "description": "saved_trees.tree",
        "peekOfCode": "def visualize_tree_from_dict(tree_dict, output_file=\"tree\"):\n    dot = Digraph()\n    def add_nodes_edges(tree, parent=None, edge_label=\"\"):\n        node_id = str(id(tree))  # unique id for Graphviz\n        if \"label\" in tree:\n            dot.node(node_id, f\"Label: {tree['label']}\", shape=\"box\", style=\"filled\", color=\"lightblue\")\n        else:\n            dot.node(node_id, f\"Feature: {tree['feature']}\", shape=\"ellipse\", style=\"filled\", color=\"lightgreen\")\n        if parent:\n            dot.edge(parent, node_id, label=edge_label)",
        "detail": "saved_trees.tree",
        "documentation": {}
    },
    {
        "label": "count_all_files",
        "kind": 2,
        "importPath": "saved_trees.tree",
        "description": "saved_trees.tree",
        "peekOfCode": "def count_all_files(directory):\n    total_files = 0\n    for root, dirs, files in os.walk(directory):\n        total_files += len(files)\n    return total_files\n# 🌀 모든 json 파일을 하나씩 input_file로 넣어 시각화\nbase_dir = \"ntrees_50\"\nfor root, dirs, files in os.walk(base_dir):\n    for file in files:\n        if file.endswith(\".json\") and file.startswith(\"tree_\"):",
        "detail": "saved_trees.tree",
        "documentation": {}
    },
    {
        "label": "base_dir",
        "kind": 5,
        "importPath": "saved_trees.tree",
        "description": "saved_trees.tree",
        "peekOfCode": "base_dir = \"ntrees_50\"\nfor root, dirs, files in os.walk(base_dir):\n    for file in files:\n        if file.endswith(\".json\") and file.startswith(\"tree_\"):\n            input_file = os.path.join(root, file)\n            output_file = os.path.splitext(input_file)[0]  # 확장자 제거\n            try:\n                with open(input_file, \"r\") as f:\n                    tree_data = json.load(f)\n                visualize_tree_from_dict(tree_data, output_file)",
        "detail": "saved_trees.tree",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "try",
        "description": "try",
        "peekOfCode": "class Node:\n    # Node in the decision tree\n    def __init__(self, feature=None, threshold=None, label=None, children=None):\n        self.feature = feature\n        self.threshold = threshold\n        self.label = label\n        self.children = children if children else {}\n# Compute entropy of label distribution\n# e.g., (x=sunny)-> y = [y,y,y,n,n] -> entropy calcuate\n# e.g., all y = [y,y,y,n,n,n,n,n,y,y,y,n] -> entropy calcuate",
        "detail": "try",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "try",
        "description": "try",
        "peekOfCode": "def main():\n    ##### choose dataset #####\n    filename = \"datasets/loan.csv\" # <<<<===== changing point \n    base = os.path.basename(filename)     \n    basename = os.path.splitext(base)[0]\n    # Load dataset and preprocess it\n    data = load_and_preprocess_data(filename)\n    # Apply stratified k-fold cross-validation\n    fold_data = cross_validation(data, k_fold=5)\n    # Train and evaluate Random Forest",
        "detail": "try",
        "documentation": {}
    },
    {
        "label": "load_and_preprocess_data",
        "kind": 2,
        "importPath": "try",
        "description": "try",
        "peekOfCode": "def load_and_preprocess_data(filepath):\n    # Load CSV and rename target column\n    data = pd.read_csv(filepath)\n    data = data.rename(columns={\"class\": \"label\"})\n    # Process each column by its suffix\n    for col in data.columns:\n        if col == \"label\":\n            continue\n        elif col.endswith(\"_cat\"):\n            data[col] = data[col].astype(str)  # Categorical feature",
        "detail": "try",
        "documentation": {}
    },
    {
        "label": "cross_validation",
        "kind": 2,
        "importPath": "try",
        "description": "try",
        "peekOfCode": "def cross_validation(data, k_fold):\n    # Separate data by class label for stratified sampling\n    class_0 = data[data['label'] == 0].reset_index(drop=True)\n    class_1 = data[data['label'] == 1].reset_index(drop=True)\n    # proceed seperate class_0(label=0 sub dataset), class_1(label=1 sub dataset) to preserve proportions\n    all_data = pd.DataFrame()\n    for i in range(k_fold):\n        # Slice each class proportionally into folds => satisfied disjoint condition \n        class_0_start = int(len(class_0) * i / k_fold)\n        class_0_end = int(len(class_0) * (i + 1) / k_fold)",
        "detail": "try",
        "documentation": {}
    },
    {
        "label": "evaluate_random_forest",
        "kind": 2,
        "importPath": "try",
        "description": "try",
        "peekOfCode": "def evaluate_random_forest(fold_data, k_fold):\n    ntrees_list = [1, 5, 10, 20, 30, 40, 50]\n    acc_list, prec_list, rec_list, f1_list = [], [], [], []\n    # operate in all ntrees\n    for ntrees in ntrees_list:\n        print(f\"\\nEvaluating Random Forest with {ntrees} trees\")\n        accs, precisions, recalls, f1s = [], [], [], []\n        # execute cross_validation\n        for i in range(k_fold):\n            # Split fold into training and testing",
        "detail": "try",
        "documentation": {}
    },
    {
        "label": "bootstrap_sample",
        "kind": 2,
        "importPath": "try",
        "description": "try",
        "peekOfCode": "def bootstrap_sample(X, y):\n    # random select on index\n    idxs = np.random.choice(len(X), size=len(X), replace=True) # replacement = True\n    # get the selected index in X,y\n    X_sample = X.iloc[idxs].reset_index(drop=True)\n    y_sample = y.iloc[idxs].reset_index(drop=True)\n    # return same as input\n    return X_sample, y_sample\n##################################### make decision tree ##################################### \n# ===== Entropy & Tree Node Class =====",
        "detail": "try",
        "documentation": {}
    },
    {
        "label": "entropy",
        "kind": 2,
        "importPath": "try",
        "description": "try",
        "peekOfCode": "def entropy(y):\n    # count label and change to series\n    class_counts = y.value_counts()\n    # divided by total length\n    probabilities = class_counts / len(y)\n    # entropy = sum(- prob * log2(prob))\n    return -np.sum(probabilities * np.log2(probabilities))\ndef build_tree(X, y, features, depth=0):\n    ####### Stop splitting node criteria (maximal_depth and minimal_gain are combined) ####### \n    # depth = 0 --> check current node depth to confirm when depth reached to max_depth",
        "detail": "try",
        "documentation": {}
    },
    {
        "label": "build_tree",
        "kind": 2,
        "importPath": "try",
        "description": "try",
        "peekOfCode": "def build_tree(X, y, features, depth=0):\n    ####### Stop splitting node criteria (maximal_depth and minimal_gain are combined) ####### \n    # depth = 0 --> check current node depth to confirm when depth reached to max_depth\n    max_depth=5 # maximal_depth\n    min_info_gain=1e-5 # minimal_gain\n    ### Check Stop Spliting condition ===> maximal_depth\n    # unique -> check all the same class\n    # len(features) -> no features left\n    # current depth = max_depth\n    if len(y.unique()) == 1 or len(features) == 0 or depth == max_depth:",
        "detail": "try",
        "documentation": {}
    },
    {
        "label": "random_forest_predict",
        "kind": 2,
        "importPath": "try",
        "description": "try",
        "peekOfCode": "def random_forest_predict(trees, X_test):\n    # Collect predictions from all trees (shape: [num_trees, num_X_test_samples])\n    # k-fold function result => test dataset fixed\n    # test sample : 3, tree: 4 => [[1,0,0],[1,1,1],[0,1,1],[1,1,1]]\n    tree_preds = np.array([predict(tree, X_test) for tree in trees])\n    # Total number of test samples\n    test_all = X_test.shape[0]  \n    # List to store final predictions after majority voting\n    final_preds = [] \n    # Iterate over each sample",
        "detail": "try",
        "documentation": {}
    },
    {
        "label": "predict",
        "kind": 2,
        "importPath": "try",
        "description": "try",
        "peekOfCode": "def predict(tree, X_test):\n    # gather all the prediction results\n    predictions = []\n    ##### repeat X_test counts #####\n    # get index(not using), row(samples) from itterows\n    for index, row in X_test.iterrows(): # iterate row by row\n        # initialize the node = tree\n        # each sample starts to search from root of tree\n        node = tree\n        # repeat until reaching out to the leaf node (label exist -> leaf node)",
        "detail": "try",
        "documentation": {}
    },
    {
        "label": "accuracy",
        "kind": 2,
        "importPath": "try",
        "description": "try",
        "peekOfCode": "def accuracy(predictions, true_labels):\n    predictions = np.array(predictions)\n    true_labels = np.array(true_labels)\n    valid = predictions != None\n    return np.mean(predictions[valid] == true_labels[valid])\n# Calculate precision\ndef precision(y_true, y_pred):\n    tp = np.sum((y_pred == 1) & (y_true == 1))\n    fp = np.sum((y_pred == 1) & (y_true == 0))\n    return tp / (tp + fp) if (tp + fp) > 0 else 0.0",
        "detail": "try",
        "documentation": {}
    },
    {
        "label": "precision",
        "kind": 2,
        "importPath": "try",
        "description": "try",
        "peekOfCode": "def precision(y_true, y_pred):\n    tp = np.sum((y_pred == 1) & (y_true == 1))\n    fp = np.sum((y_pred == 1) & (y_true == 0))\n    return tp / (tp + fp) if (tp + fp) > 0 else 0.0\n# Calculate recall\ndef recall(y_true, y_pred):\n    tp = np.sum((y_pred == 1) & (y_true == 1))\n    fn = np.sum((y_pred == 0) & (y_true == 1))\n    return tp / (tp + fn) if (tp + fn) > 0 else 0.0\n# Calculate F1-score",
        "detail": "try",
        "documentation": {}
    },
    {
        "label": "recall",
        "kind": 2,
        "importPath": "try",
        "description": "try",
        "peekOfCode": "def recall(y_true, y_pred):\n    tp = np.sum((y_pred == 1) & (y_true == 1))\n    fn = np.sum((y_pred == 0) & (y_true == 1))\n    return tp / (tp + fn) if (tp + fn) > 0 else 0.0\n# Calculate F1-score\ndef f1_score_manual(y_true, y_pred):\n    p = precision(y_true, y_pred)\n    r = recall(y_true, y_pred)\n    return 2 * p * r / (p + r) if (p + r) > 0 else 0.0\n##################################### plot the metrics ##################################### ",
        "detail": "try",
        "documentation": {}
    },
    {
        "label": "f1_score_manual",
        "kind": 2,
        "importPath": "try",
        "description": "try",
        "peekOfCode": "def f1_score_manual(y_true, y_pred):\n    p = precision(y_true, y_pred)\n    r = recall(y_true, y_pred)\n    return 2 * p * r / (p + r) if (p + r) > 0 else 0.0\n##################################### plot the metrics ##################################### \n# def plot_metrics(basename, ntrees_list, metrics, save_dir):\n#     titles = [\"Accuracy\", \"Precision\", \"Recall\", \"F1 Score\"]\n#     filenames = [\"accuracy.png\", \"precision.png\", \"recall.png\", \"f1score.png\"]\n#     os.makedirs(save_dir, exist_ok=True)\n#     for metric, title, fname in zip(metrics, titles, filenames):",
        "detail": "try",
        "documentation": {}
    },
    {
        "label": "plot_metrics",
        "kind": 2,
        "importPath": "try",
        "description": "try",
        "peekOfCode": "def plot_metrics(basename, ntrees_list, metrics, save_dir):\n    titles = [\"Accuracy\", \"Precision\", \"Recall\", \"F1 Score\"]\n    os.makedirs(save_dir, exist_ok=True)\n    plt.figure(figsize=(12, 10))  # 전체 크기 설정 (2행 2열 서브플롯)\n    for i, (metric, title) in enumerate(zip(metrics, titles), 1):\n        plt.subplot(2, 2, i)  # 2행 2열 중 i번째 subplot\n        plt.plot(ntrees_list, metric, marker='o')\n        plt.title(title)\n        plt.xlabel(\"ntrees\")\n        plt.grid(True)",
        "detail": "try",
        "documentation": {}
    },
    {
        "label": "tree_to_dict",
        "kind": 2,
        "importPath": "try",
        "description": "try",
        "peekOfCode": "def tree_to_dict(node):\n    if node.label is not None:\n        return {\"label\": int(node.label)}\n    return {\n        \"feature\": node.feature,\n        \"threshold\": node.threshold,\n        \"children\": {str(k): tree_to_dict(v) for k, v in node.children.items()}\n    }\n# Save all trees in the forest as JSON files\ndef save_trees_as_json(trees, ntrees, base_dir=\"saved_trees\"):",
        "detail": "try",
        "documentation": {}
    },
    {
        "label": "save_trees_as_json",
        "kind": 2,
        "importPath": "try",
        "description": "try",
        "peekOfCode": "def save_trees_as_json(trees, ntrees, base_dir=\"saved_trees\"):\n    folder = os.path.join(base_dir, f\"ntrees_{ntrees}\")\n    os.makedirs(folder, exist_ok=True)\n    for i, tree in enumerate(trees, start=1):\n        tree_dict = tree_to_dict(tree)\n        with open(os.path.join(folder, f\"tree_{i}.json\"), \"w\") as f:\n            json.dump(tree_dict, f, indent=4)\nif __name__ == \"__main__\":\n    main()",
        "detail": "try",
        "documentation": {}
    }
]